{"version":3,"file":"type-route.cjs.production.min.js","sources":["../src/asArray.ts","../src/buildPathDefs.ts","../src/getParamDefsOfType.ts","../src/createLocation.ts","../src/noMatch.ts","../src/stringUtils.ts","../src/getPathMatch.ts","../src/getObjectMatch.ts","../src/createMatcher.ts","../src/getQueryMatch.ts","../src/getStateMatch.ts","../src/preventDefaultLinkClickBehavior.ts","../src/buildRoute.ts","../src/createRouteBuilder.ts","../src/createQueryStringSerializer.ts","../src/getMatchingRoute.ts","../src/convertToRouterLocationFromHistoryLocation.ts","../src/getRouteByHref.ts","../src/createNavigationHandlerManager.ts","../src/attemptScrollToTop.ts","../src/serializeStateParams.ts","../src/createRouter.ts","../src/defineRoute.ts","../src/param.ts","../src/createGroup.ts"],"sourcesContent":["export function asArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n","import { TypeRouteError } from \"./TypeRouteError\";\nimport {\n  PathParamDef,\n  NamedPathParamDef,\n  BuildPathDefErrorContext,\n  GetRawPath,\n  PathDef,\n  ParamIdCollection,\n} from \"./types\";\nimport { asArray } from \"./asArray\";\nimport { assert } from \"./assert\";\n\nexport function buildPathDefs(\n  routeName: string,\n  pathParamDefCollection: Record<string, PathParamDef>,\n  getRawPath: GetRawPath\n): PathDef[] {\n  const namedPathParamDefs = Object.keys(pathParamDefCollection).map(\n    (paramName) => {\n      const namedPathParameterDefinition: NamedPathParamDef = {\n        paramName,\n        ...pathParamDefCollection[paramName],\n      };\n\n      return namedPathParameterDefinition;\n    }\n  );\n\n  const paramIdCollection: ParamIdCollection = {};\n\n  namedPathParamDefs.forEach(({ paramName }) => {\n    if (__DEV__) {\n      if (\n        paramName.indexOf(\"$\") >= 0 ||\n        paramName.indexOf(\"{\") >= 0 ||\n        paramName.indexOf(\"}\") >= 0 ||\n        paramName.indexOf(\"/\") >= 0\n      ) {\n        throw TypeRouteError.Path_parameter_name_must_not_include_curly_brackets_dollar_signs_or_the_forward_slash_character.create(\n          routeName,\n          paramName\n        );\n      }\n    }\n\n    paramIdCollection[paramName] = getParamId(paramName);\n  });\n\n  const rawPath = getRawPath(paramIdCollection);\n\n  if (__DEV__) {\n    if (Array.isArray(rawPath)) {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.arrayOfType(\"string\", \"path\", rawPath),\n        assert.arrayLength(rawPath, 1, Infinity),\n      ]);\n    } else {\n      assert(`ReturnType<${routeName}.path>`, [\n        assert.type(\"string\", \"path\", rawPath),\n      ]);\n    }\n  }\n\n  return asArray(rawPath).map((rawPath) => {\n    const errorContext: BuildPathDefErrorContext = {\n      rawPath,\n      routeName,\n    };\n\n    if (__DEV__) {\n      if (rawPath.length === 0) {\n        throw TypeRouteError.Path_may_not_be_an_empty_string.create(\n          errorContext\n        );\n      }\n\n      if (rawPath[0] !== \"/\") {\n        throw TypeRouteError.Path_must_start_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    if (rawPath.length === 1) {\n      return [];\n    }\n\n    if (__DEV__) {\n      if (rawPath.length > 0 && rawPath[rawPath.length - 1] === \"/\") {\n        throw TypeRouteError.Path_may_not_end_with_a_forward_slash.create(\n          errorContext\n        );\n      }\n    }\n\n    const rawPathSegments = rawPath.split(\"/\").slice(1);\n\n    const usedPathParams: Record<string, true> = {};\n    const pathDef: PathDef = [];\n\n    for (const rawSegment of rawPathSegments) {\n      if (__DEV__) {\n        if (rawSegment.length === 0) {\n          throw TypeRouteError.Path_may_not_include_empty_segments.create(\n            errorContext\n          );\n        }\n      }\n\n      let includedParamDef: NamedPathParamDef<unknown> | null = null;\n\n      for (const paramDef of namedPathParamDefs) {\n        if (rawSegment.indexOf(getParamId(paramDef.paramName)) >= 0) {\n          if (__DEV__) {\n            if (includedParamDef !== null) {\n              throw TypeRouteError.Path_may_have_at_most_one_parameter_per_segment.create(\n                errorContext,\n                [paramDef.paramName, includedParamDef.paramName]\n              );\n            }\n\n            if (usedPathParams[paramDef.paramName]) {\n              throw TypeRouteError.Path_parameters_may_not_be_used_more_than_once_when_building_a_path.create(\n                errorContext,\n                paramDef.paramName\n              );\n            }\n          }\n\n          includedParamDef = paramDef;\n          usedPathParams[paramDef.paramName] = true;\n        }\n      }\n\n      if (includedParamDef) {\n        const [leading, trailing] = rawSegment.split(\n          getParamId(includedParamDef.paramName)\n        );\n\n        if (__DEV__) {\n          if (\n            encodeURIComponent(leading) !== leading ||\n            encodeURIComponent(trailing) !== trailing\n          ) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              {\n                leading,\n                paramId: getParamId(includedParamDef.paramName),\n                trailing,\n              }\n            );\n          }\n\n          if (\n            includedParamDef[\"~internal\"].optional &&\n            (leading !== \"\" || trailing !== \"\")\n          ) {\n            throw TypeRouteError.Optional_path_parameters_may_not_have_any_text_around_the_parameter.create(\n              errorContext,\n              includedParamDef.paramName,\n              leading,\n              trailing\n            );\n          }\n        }\n\n        pathDef.push({\n          leading,\n          trailing,\n          namedParamDef: includedParamDef,\n        });\n      } else {\n        if (__DEV__) {\n          if (encodeURIComponent(rawSegment) !== rawSegment) {\n            throw TypeRouteError.Path_may_not_include_characters_that_must_be_URL_encoded.create(\n              errorContext,\n              { leading: rawSegment }\n            );\n          }\n        }\n\n        pathDef.push({\n          leading: rawSegment,\n          trailing: \"\",\n          namedParamDef: null,\n        });\n      }\n    }\n\n    const numOptionalOrTrailingParams = pathDef.filter(\n      (part) =>\n        part.namedParamDef?.[\"~internal\"].optional ||\n        part.namedParamDef?.[\"~internal\"].trailing\n    ).length;\n\n    if (__DEV__) {\n      if (numOptionalOrTrailingParams > 1) {\n        throw TypeRouteError.Path_may_have_at_most_one_optional_or_trailing_parameter.create(\n          errorContext,\n          numOptionalOrTrailingParams\n        );\n      }\n    }\n\n    const lastPathSegmentParameterDefinition =\n      pathDef[pathDef.length - 1].namedParamDef;\n\n    if (__DEV__) {\n      if (\n        numOptionalOrTrailingParams === 1 &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].optional &&\n        !lastPathSegmentParameterDefinition?.[\"~internal\"].trailing\n      ) {\n        throw TypeRouteError.Optional_or_trailing_path_parameters_may_only_appear_in_the_last_path_segment.create(\n          errorContext\n        );\n      }\n    }\n\n    const unusedPathParameterDefinitions = namedPathParamDefs\n      .map(({ paramName: name }) => name)\n      .filter((name) => !usedPathParams[name]);\n\n    if (__DEV__) {\n      if (unusedPathParameterDefinitions.length > 0) {\n        throw TypeRouteError.All_path_parameters_must_be_used_in_path_construction.create(\n          errorContext,\n          unusedPathParameterDefinitions\n        );\n      }\n    }\n\n    return pathDef;\n  });\n}\n\nfunction getParamId(parameterName: string) {\n  return \"${p.\" + parameterName + \"}\";\n}\n","import { ParamDefKind, ParamDefCollection } from \"./types\";\n\nexport function getParamDefsOfType<TParamType extends ParamDefKind>(\n  type: TParamType,\n  paramDefCollection: ParamDefCollection<ParamDefKind>\n) {\n  const filteredParamDefCollection: ParamDefCollection<TParamType> = {};\n\n  Object.keys(paramDefCollection).forEach((name) => {\n    const paramDef = paramDefCollection[name];\n    if (paramDef[\"~internal\"].kind === type) {\n      filteredParamDefCollection[name] =\n        paramDef as ParamDefCollection<TParamType>[string];\n    }\n  });\n\n  return filteredParamDefCollection;\n}\n","import {\n  RouterLocation,\n  UmbrellaParamDef,\n  UmbrellaParamDefCollection,\n  QueryStringSerializer,\n  PathDef,\n} from \"./types\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { typeOf } from \"./typeOf\";\n\ntype ParamWithContextCollection = Record<\n  string,\n  { valueSerializerId?: string; array: boolean; value: string | null }\n>;\n\nexport function createLocation({\n  paramCollection,\n  paramDefCollection,\n  arraySeparator,\n  queryStringSerializer,\n  pathDefs,\n  baseUrl,\n}: {\n  paramCollection: Record<string, unknown>;\n  paramDefCollection: UmbrellaParamDefCollection;\n  arraySeparator: string;\n  queryStringSerializer: QueryStringSerializer;\n  pathDefs: PathDef[];\n  baseUrl: string;\n}): RouterLocation {\n  const params = {\n    path: {} as ParamWithContextCollection,\n    query: {} as ParamWithContextCollection,\n    state: {} as ParamWithContextCollection,\n  };\n\n  for (const paramName in paramDefCollection) {\n    const paramValue = paramCollection[paramName];\n\n    if (paramValue === undefined) {\n      continue;\n    }\n\n    const paramDef = paramDefCollection[paramName];\n    const urlEncodeDefault =\n      paramDef[\"~internal\"].kind !== \"state\" && !paramDef[\"~internal\"].trailing;\n    const urlEncode =\n      paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault;\n\n    const getValue = (paramValue: unknown) => {\n      let value: string | null;\n\n      if (paramDef[\"~internal\"].array) {\n        if (!Array.isArray(paramValue)) {\n          if (__DEV__) {\n            throw TypeRouteError.Expected_type_does_not_match_actual_type.create(\n              {\n                context: \"routes[routeName](...)\",\n                actualType: typeOf(paramValue),\n                expectedType: \"array\",\n                value: paramValue,\n                valueName: paramName,\n              }\n            );\n          }\n        }\n\n        value =\n          (paramValue as unknown[]).length === 0\n            ? null\n            : (paramValue as unknown[])\n                .map((part) => stringify(paramDef, part, urlEncode))\n                .join(arraySeparator);\n      } else {\n        value = stringify(paramDef, paramValue, urlEncode);\n      }\n\n      return value;\n    };\n\n    const value = getValue(paramValue);\n\n    if (\n      paramDef[\"~internal\"].kind === \"query\" &&\n      paramDef[\"~internal\"].default !== undefined &&\n      getValue(paramDef[\"~internal\"].default) === value\n    ) {\n      continue;\n    }\n\n    params[paramDef[\"~internal\"].kind][paramName] = {\n      valueSerializerId: paramDef[\"~internal\"].valueSerializer.id,\n      array: paramDef[\"~internal\"].array,\n      value,\n    };\n  }\n\n  const path =\n    \"/\" +\n    pathDefs[0]\n      .filter(({ namedParamDef }) => {\n        return !(\n          namedParamDef?.[\"~internal\"].optional &&\n          params.path[namedParamDef.paramName] === undefined\n        );\n      })\n      .map(({ namedParamDef, leading, trailing }) => {\n        const rawParam = namedParamDef\n          ? params.path[namedParamDef.paramName].value\n          : \"\";\n        return leading + rawParam + trailing;\n      })\n      .join(\"/\");\n\n  const hasQueryParams = Object.keys(params.query).length > 0;\n\n  const query = hasQueryParams\n    ? queryStringSerializer.stringify(params.query)\n    : undefined;\n\n  if (__DEV__) {\n    if (hasQueryParams) {\n      assert(\"query\", [assert.type(\"string\", \"query\", query)]);\n    }\n  }\n\n  const state =\n    Object.keys(params.state).length === 0\n      ? undefined\n      : Object.keys(params.state).reduce(\n          (state, key) => ({\n            ...state,\n            [key]: params.state[key].value,\n          }),\n          {}\n        );\n\n  return {\n    fullPath: (baseUrl === \"/\" ? \"\" : baseUrl) + path,\n    path,\n    query,\n    state,\n  };\n}\n\nfunction stringify(\n  paramDef: UmbrellaParamDef,\n  value: unknown,\n  urlEncode: boolean\n) {\n  const result = paramDef[\"~internal\"].valueSerializer.stringify(value);\n\n  if (__DEV__) {\n    assert(\"[ValueSerializer].stringify\", [\n      assert.type(\"string\", \"result\", result),\n    ]);\n  }\n\n  return urlEncode ? encodeURIComponent(result) : result;\n}\n","export const noMatch = { __noMatch: true } as const;\n","export const stringUtils = { startsWith, endsWith, splitFirst };\n\nfunction startsWith(value: string, start: string) {\n  for (let i = 0; i < start.length; i++) {\n    if (start[i] !== value[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction endsWith(value: string, end: string) {\n  for (let i = 1; i <= end.length; i++) {\n    if (end[end.length - i] !== value[value.length - i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction splitFirst(value: string, split: string) {\n  const [first, ...rest] = value.split(split);\n  return [first, rest.join(split)] as const;\n}\n","import { noMatch } from \"./noMatch\";\nimport { PathDef } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { endsWith, startsWith } = stringUtils;\n\nexport function getPathMatch({\n  path,\n  pathDefs,\n  arraySeparator,\n}: {\n  path: string;\n  pathDefs: PathDef[];\n  arraySeparator: string;\n}) {\n  for (let index = 0; index < pathDefs.length; index++) {\n    const result = match(pathDefs[index]);\n    if (result !== false) {\n      return { ...result, primaryPath: index === 0 };\n    }\n  }\n\n  return false;\n\n  function match(pathDef: PathDef) {\n    const params: Record<string, unknown> = {};\n\n    if (path === \"/\" && pathDef.length === 0) {\n      return { params, numExtraneousParams: 0 };\n    }\n\n    const pathHasTrailingSlash = path.length > 1 && endsWith(path, \"/\");\n\n    if (pathHasTrailingSlash) {\n      path = path.slice(0, path.length - 1);\n    }\n\n    const pathSegmentList = path.split(\"/\").slice(1);\n\n    for (\n      let segmentIndex = 0;\n      segmentIndex < Math.max(pathDef.length, pathSegmentList.length);\n      segmentIndex++\n    ) {\n      const pathSegmentDef =\n        segmentIndex >= pathDef.length ? null : pathDef[segmentIndex];\n      let pathSegment =\n        segmentIndex >= pathSegmentList.length\n          ? null\n          : pathSegmentList[segmentIndex];\n\n      if (pathSegmentDef === null) {\n        return false;\n      }\n\n      const numRemainingPathSegmentDefs = pathDef.length - 1 - segmentIndex;\n\n      if (pathSegment === null) {\n        if (\n          numRemainingPathSegmentDefs !== 0 ||\n          !pathSegmentDef.namedParamDef?.[\"~internal\"].optional\n        ) {\n          return false;\n        }\n\n        break;\n      }\n\n      if (pathSegmentDef.namedParamDef?.[\"~internal\"].trailing) {\n        pathSegment = pathSegmentList.slice(segmentIndex).join(\"/\");\n      }\n\n      if (!startsWith(pathSegment, pathSegmentDef.leading)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeading = pathSegment.slice(\n        pathSegmentDef.leading.length\n      );\n\n      if (!endsWith(pathSegmentMinusLeading, pathSegmentDef.trailing)) {\n        return false;\n      }\n\n      const pathSegmentMinusLeadingAndTrailing = pathSegmentMinusLeading.slice(\n        0,\n        pathSegmentMinusLeading.length - pathSegmentDef.trailing.length\n      );\n\n      if (!pathSegmentDef.namedParamDef) {\n        if (pathSegmentMinusLeadingAndTrailing === \"\") {\n          continue;\n        }\n\n        return false;\n      }\n\n      if (pathSegmentMinusLeadingAndTrailing === \"\") {\n        if (pathSegmentDef.namedParamDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n\n      const urlEncode =\n        pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.urlEncode ??\n        !pathSegmentDef.namedParamDef[\"~internal\"].trailing;\n\n      let value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].array) {\n        value = pathSegmentMinusLeadingAndTrailing\n          .split(arraySeparator)\n          .map((part) => {\n            return pathSegmentDef.namedParamDef?.[\n              \"~internal\"\n            ].valueSerializer.parse(\n              urlEncode ? decodeURIComponent(part) : part\n            );\n          });\n\n        if (value.some((part) => part === noMatch)) {\n          return false;\n        }\n      } else {\n        value = pathSegmentDef.namedParamDef[\"~internal\"].valueSerializer.parse(\n          urlEncode\n            ? decodeURIComponent(pathSegmentMinusLeadingAndTrailing)\n            : pathSegmentMinusLeadingAndTrailing\n        );\n\n        if (value === noMatch) {\n          return false;\n        }\n      }\n\n      if (\n        pathSegmentDef.namedParamDef[\"~internal\"].trailing &&\n        pathHasTrailingSlash &&\n        pathSegmentDef.trailing === \"\"\n      ) {\n        value = `${value}/`;\n      }\n\n      params[pathSegmentDef.namedParamDef.paramName] = value;\n\n      if (pathSegmentDef.namedParamDef[\"~internal\"].trailing) {\n        break;\n      }\n    }\n\n    return { params, numExtraneousParams: 0 };\n  }\n}\n","import { UmbrellaParamDefCollection } from \"./types\";\nimport { noMatch } from \"./noMatch\";\n\nexport function getObjectMatch({\n  object,\n  paramDefs,\n  urlEncodeDefault,\n  arraySeparator,\n}: {\n  object: Record<string, string | null>;\n  paramDefs: UmbrellaParamDefCollection;\n  urlEncodeDefault: boolean;\n  arraySeparator: string;\n}) {\n  const params: Record<string, unknown> = {};\n\n  const namedParamDefs = Object.keys(paramDefs).map((name) => {\n    return { name, ...paramDefs[name] };\n  });\n\n  const extraneousParams = { ...object };\n\n  for (const paramDef of namedParamDefs) {\n    let raw = object[paramDef.name];\n    delete extraneousParams[paramDef.name];\n\n    if (raw === undefined) {\n      if (paramDef[\"~internal\"].optional) {\n        continue;\n      }\n\n      return false;\n    }\n\n    let value;\n\n    if (raw === null) {\n      if (paramDef[\"~internal\"].array) {\n        value = [];\n      } else if (paramDef[\"~internal\"].optional) {\n        continue;\n      } else {\n        return false;\n      }\n    } else if (paramDef[\"~internal\"].array) {\n      value = raw.split(arraySeparator).map((part) => {\n        return paramDef[\"~internal\"].valueSerializer.parse(\n          paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n            ? decodeURIComponent(part)\n            : part\n        );\n      });\n\n      if (value.some((part) => part === noMatch)) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    } else {\n      value = paramDef[\"~internal\"].valueSerializer.parse(\n        paramDef[\"~internal\"].valueSerializer.urlEncode ?? urlEncodeDefault\n          ? decodeURIComponent(raw)\n          : raw\n      );\n\n      if (value === noMatch) {\n        if (paramDef[\"~internal\"].optional) {\n          continue;\n        }\n\n        return false;\n      }\n    }\n\n    params[paramDef.name] = value;\n  }\n\n  return { params, numExtraneousParams: Object.keys(extraneousParams).length };\n}\n","import {\n  RouterLocation,\n  PathDef,\n  QueryStringSerializer,\n  UmbrellaParamDefCollection,\n} from \"./types\";\nimport { getPathMatch } from \"./getPathMatch\";\nimport { getStateMatch } from \"./getStateMatch\";\nimport { getQueryMatch } from \"./getQueryMatch\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\n\nexport function createMatcher({\n  pathDefs,\n  params,\n}: {\n  pathDefs: PathDef[];\n  params: UmbrellaParamDefCollection;\n}) {\n  const queryParamDefCollection = getParamDefsOfType(\"query\", params);\n  const stateParamDefCollection = getParamDefsOfType(\"state\", params);\n\n  const defaultParams: Record<string, unknown> = {};\n\n  Object.keys(params).forEach((paramName) => {\n    const param = params[paramName];\n    if (param[\"~internal\"].default === undefined) {\n      return;\n    }\n    defaultParams[paramName] = param[\"~internal\"].default;\n  });\n\n  return ({\n    routerLocation,\n    arraySeparator,\n    queryStringSerializer,\n  }: {\n    routerLocation: RouterLocation;\n    queryStringSerializer: QueryStringSerializer;\n    arraySeparator: string;\n  }) => {\n    if (routerLocation.path === undefined) {\n      return false;\n    }\n\n    const pathMatch = getPathMatch({\n      path: routerLocation.path,\n      pathDefs,\n      arraySeparator,\n    });\n\n    if (pathMatch === false) {\n      return false;\n    }\n\n    const queryMatch = getQueryMatch(\n      routerLocation.query,\n      queryParamDefCollection,\n      queryStringSerializer,\n      arraySeparator\n    );\n    if (queryMatch === false) {\n      return false;\n    }\n\n    const stateMatch = getStateMatch(\n      routerLocation.state,\n      stateParamDefCollection,\n      arraySeparator\n    );\n    if (stateMatch === false) {\n      return false;\n    }\n\n    return {\n      primaryPath: pathMatch.primaryPath,\n      params: {\n        ...defaultParams,\n        ...pathMatch.params,\n        ...queryMatch.params,\n        ...stateMatch.params,\n      },\n      numExtraneousParams:\n        pathMatch.numExtraneousParams +\n        queryMatch.numExtraneousParams +\n        stateMatch.numExtraneousParams,\n    };\n  };\n}\n","import { getObjectMatch } from \"./getObjectMatch\";\nimport { ParamDefCollection, QueryStringSerializer } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function getQueryMatch(\n  query: string | undefined,\n  paramDefs: ParamDefCollection<\"query\">,\n  queryStringSerializer: QueryStringSerializer,\n  arraySeparator: string\n) {\n  let object: Record<string, string | null> = {};\n\n  if (query) {\n    object = queryStringSerializer.parse(query);\n\n    if (__DEV__) {\n      assert(\"[QueryStringSerializer].parse\", [\n        assert.collectionOfType(\n          [\"string\", \"null\"],\n          \"parsedQueryString\",\n          object\n        ),\n      ]);\n    }\n  }\n\n  return getObjectMatch({\n    object,\n    paramDefs,\n    urlEncodeDefault: true,\n    arraySeparator,\n  });\n}\n","import { ParamDefCollection } from \"./types\";\nimport { getObjectMatch } from \"./getObjectMatch\";\n\nexport function getStateMatch(\n  state: Record<string, string> | undefined,\n  paramDefs: ParamDefCollection<\"state\">,\n  arraySeparator: string\n) {\n  return getObjectMatch({\n    object: state ?? {},\n    paramDefs,\n    urlEncodeDefault: false,\n    arraySeparator,\n  });\n}\n","import { ClickEvent } from \"./types\";\n\nexport function preventDefaultLinkClickBehavior(event: any = {}) {\n  const e = event as ClickEvent;\n  const isModifiedEvent = !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);\n\n  const isSelfTarget =\n    !e.target || !e.target.target || e.target.target === \"_self\";\n\n  if (\n    isSelfTarget && // Ignore everything but links with target self\n    !e.defaultPrevented && // onClick prevented default\n    e.button === 0 && // ignore everything but left clicks\n    !isModifiedEvent // ignore clicks with modifier keys\n  ) {\n    if (e && e.preventDefault) {\n      e.preventDefault();\n    }\n\n    return true;\n  }\n\n  return false;\n}\n","import {\n  UmbrellaRoute,\n  RouterLocation,\n  RouterContext,\n  NavigateOptions,\n} from \"./types\";\nimport { preventDefaultLinkClickBehavior } from \"./preventDefaultLinkClickBehavior\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function buildRoute({\n  routeName,\n  params,\n  location,\n  routerContext,\n}: {\n  routeName: string | false;\n  params: Record<string, unknown>;\n  location: RouterLocation;\n  routerContext: RouterContext;\n}): UmbrellaRoute {\n  const { navigate, history } = routerContext;\n\n  let href = history.createHref({\n    pathname: routeName === false ? location.fullPath : location.path,\n    search: location.query ? \"?\" + location.query : \"\",\n  });\n\n  if (startsWith(href, \"#\")) {\n    href = \"/\" + href;\n  }\n\n  if (routeName !== false && routerContext.baseUrl !== \"/\") {\n    href = routerContext.baseUrl + href;\n  }\n\n  const route: UmbrellaRoute = {\n    name: routeName,\n    params,\n    href,\n    link: {\n      href,\n      onClick: (event) => {\n        if (preventDefaultLinkClickBehavior(event)) {\n          return route.push();\n        }\n      },\n    },\n    action: null,\n    push: (options?: NavigateOptions) =>\n      navigate({ ...route, action: \"push\" }, true, options),\n    replace: (options?: NavigateOptions) =>\n      navigate({ ...route, action: \"replace\" }, true, options),\n  };\n\n  return route;\n}\n","import { UmbrellaRouteDef, UmbrellaRouteBuilder, RouterContext } from \"./types\";\nimport { buildPathDefs } from \"./buildPathDefs\";\nimport { getParamDefsOfType } from \"./getParamDefsOfType\";\nimport { createLocation } from \"./createLocation\";\nimport { createMatcher } from \"./createMatcher\";\nimport { assert } from \"./assert\";\nimport { buildRoute } from \"./buildRoute\";\nimport { TypeRouteError } from \"./TypeRouteError\";\n\nexport function createRouteBuilder(\n  routeName: string,\n  routeDef: UmbrellaRouteDef,\n  getRouterContext: () => RouterContext\n): UmbrellaRouteBuilder {\n  const pathDefs = buildPathDefs(\n    routeName,\n    getParamDefsOfType(\"path\", routeDef[\"~internal\"].params),\n    routeDef[\"~internal\"].path\n  );\n\n  const build: UmbrellaRouteBuilder = function (\n    params: Record<string, unknown> = {}\n  ) {\n    if (__DEV__) {\n      assert(`routes.${routeName}`, [\n        assert.numArgs([].slice.call(arguments), 0, 1),\n        assert.type(\"object\", \"params\", params),\n      ]);\n\n      for (const paramKey in params) {\n        if (!(paramKey in routeDef[\"~internal\"].params)) {\n          throw TypeRouteError.Encountered_unexpected_parameter_when_building_route.create(\n            {\n              routeName,\n              unexpectedParameterName: paramKey,\n              allowedParameterNames: Object.keys(routeDef[\"~internal\"].params),\n            }\n          );\n        }\n      }\n\n      for (const paramKey in routeDef[\"~internal\"].params) {\n        const value = params[paramKey];\n        const paramDef = routeDef[\"~internal\"].params[paramKey][\"~internal\"];\n\n        if (value === undefined) {\n          if (!paramDef.optional) {\n            throw TypeRouteError.Missing_required_parameter_when_building_route.create(\n              {\n                routeName,\n                missingParameterName: paramKey,\n              }\n            );\n          }\n\n          continue;\n        }\n      }\n    }\n\n    const routerContext = getRouterContext();\n\n    const { arraySeparator, queryStringSerializer, baseUrl } = routerContext;\n\n    const paramsWithDefault = { ...params };\n\n    Object.keys(routeDef[\"~internal\"].params).forEach((paramName) => {\n      const paramDef = routeDef[\"~internal\"].params[paramName];\n\n      if (\n        paramsWithDefault[paramName] === undefined &&\n        paramDef[\"~internal\"].default !== undefined\n      ) {\n        paramsWithDefault[paramName] = paramDef[\"~internal\"].default;\n      }\n    });\n\n    const location = createLocation({\n      paramCollection: params,\n      paramDefCollection: routeDef[\"~internal\"].params,\n      arraySeparator,\n      queryStringSerializer,\n      pathDefs,\n      baseUrl,\n    });\n\n    return buildRoute({\n      routeName,\n      params: paramsWithDefault,\n      location,\n      routerContext,\n    }) as any;\n  };\n\n  Object.defineProperty(build, \"name\", { value: routeName });\n\n  build[\"~internal\"] = {\n    type: \"RouteBuilder\",\n    match: createMatcher({\n      pathDefs,\n      params: routeDef[\"~internal\"].params,\n    }) as any,\n    pathDefs,\n    Route: null as any,\n  };\n\n  return build;\n}\n","import { QueryStringSerializer, QueryStringArrayFormat } from \"./types\";\nimport { stringUtils } from \"./stringUtils\";\n\nexport function createQueryStringSerializer(\n  args: {\n    queryStringArrayFormat?: QueryStringArrayFormat;\n    arraySeparator?: string;\n  } = {}\n): QueryStringSerializer {\n  const queryStringArrayFormat =\n    args.queryStringArrayFormat ?? \"singleKeyWithBracket\";\n  const arraySeparator = args.arraySeparator ?? \",\";\n\n  const multiKey =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"multiKeyWithBracket\";\n\n  const arrayKeySuffix =\n    queryStringArrayFormat === \"multiKey\" ||\n    queryStringArrayFormat === \"singleKey\"\n      ? \"\"\n      : \"[]\";\n\n  return {\n    parse: (raw) => {\n      const queryParams: Record<string, string | null> = {};\n\n      for (const part of raw.split(\"&\")) {\n        const [rawParamName, rawParamValue, ...rest] = part.split(\"=\");\n\n        if (rawParamName === undefined || rest.length > 0) {\n          continue;\n        }\n\n        const key = decodeURIComponent(\n          stringUtils.endsWith(rawParamName, arrayKeySuffix)\n            ? rawParamName.slice(0, rawParamName.length - arrayKeySuffix.length)\n            : rawParamName\n        );\n\n        if (rawParamValue === undefined) {\n          queryParams[key] = null;\n        } else if (queryParams[key] && multiKey) {\n          queryParams[key] += `${arraySeparator}${rawParamValue}`;\n        } else {\n          queryParams[key] = rawParamValue;\n        }\n      }\n\n      return queryParams;\n    },\n\n    stringify: (queryParams) => {\n      return Object.keys(queryParams)\n        .map((name) => {\n          const encodedName = encodeURIComponent(name);\n          const key = queryParams[name].array\n            ? `${encodedName}${arrayKeySuffix}`\n            : encodedName;\n          const value = queryParams[name].value;\n\n          if (value === null) {\n            return key;\n          }\n\n          if (queryParams[name].array && multiKey) {\n            const valueParts = value.split(arraySeparator);\n            return valueParts.map((part) => `${key}=${part}`).join(\"&\");\n          }\n\n          return `${key}=${value}`;\n        })\n        .join(\"&\");\n    },\n  };\n}\n","import { RouterLocation, UmbrellaRoute, Match, RouterContext } from \"./types\";\nimport { buildRoute } from \"./buildRoute\";\n\nexport function getMatchingRoute(\n  location: RouterLocation,\n  routerContext: RouterContext\n): { route: UmbrellaRoute; primaryPath: boolean } {\n  const { getRoutes, queryStringSerializer, arraySeparator } = routerContext;\n\n  const routes = getRoutes();\n\n  let nonExactMatch: (Match & { routeName: string }) | false = false;\n\n  for (const routeName in routes) {\n    const match = routes[routeName][\"~internal\"].match({\n      routerLocation: location,\n      queryStringSerializer,\n      arraySeparator,\n    });\n\n    if (match === false) {\n      continue;\n    }\n\n    if (match.numExtraneousParams === 0) {\n      return {\n        route: routes[routeName](match.params),\n        primaryPath: match.primaryPath,\n      };\n    }\n\n    if (\n      nonExactMatch === false ||\n      match.numExtraneousParams < nonExactMatch.numExtraneousParams\n    ) {\n      nonExactMatch = { ...match, routeName };\n    }\n  }\n\n  if (nonExactMatch) {\n    return {\n      route: routes[nonExactMatch.routeName](nonExactMatch.params),\n      primaryPath: nonExactMatch.primaryPath,\n    };\n  }\n\n  return {\n    route: buildRoute({\n      routeName: false,\n      params: {},\n      location,\n      routerContext,\n    }),\n    primaryPath: true,\n  };\n}\n","import { RouterLocation } from \"./types\";\nimport { Location as HistoryLocation } from \"history\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { startsWith } = stringUtils;\n\nexport function convertToRouterLocationFromHistoryLocation(\n  rawLocation: Pick<HistoryLocation, \"pathname\" | \"search\" | \"state\">,\n  baseUrl: string\n): RouterLocation {\n  return {\n    fullPath: rawLocation.pathname,\n    path: startsWith(rawLocation.pathname, baseUrl)\n      ? baseUrl !== \"/\"\n        ? rawLocation.pathname.replace(baseUrl, \"\")\n        : rawLocation.pathname\n      : undefined,\n    query: rawLocation.search\n      ? startsWith(rawLocation.search, \"?\")\n        ? rawLocation.search.slice(1)\n        : rawLocation.search\n      : undefined,\n    state:\n      typeof rawLocation.state === \"object\" && rawLocation.state !== null\n        ? (rawLocation.state as { state?: Record<string, string> }).state\n        : undefined,\n  };\n}\n","import { RouterContext } from \"./types\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { stringUtils } from \"./stringUtils\";\n\nconst { splitFirst } = stringUtils;\n\nexport function getRouteByHref(\n  href: string,\n  state: any,\n  routerContext: RouterContext\n) {\n  const [pathname, search] = splitFirst(href, \"?\");\n\n  const location = convertToRouterLocationFromHistoryLocation(\n    {\n      pathname,\n      search,\n      state,\n    },\n    routerContext.baseUrl\n  );\n\n  return getMatchingRoute(location, routerContext);\n}\n","import { UmbrellaNavigationHandler } from \"./types\";\n\nexport function createNavigationHandlerManager({\n  startListening,\n  stopListening,\n}: {\n  startListening: () => void;\n  stopListening: () => void;\n}) {\n  const handlerIdList: {\n    handler: UmbrellaNavigationHandler;\n    id: number;\n  }[] = [];\n  let idCounter = 0;\n\n  return { add, getHandlers };\n\n  function getHandlers() {\n    return handlerIdList.map(({ handler }) => handler);\n  }\n\n  function add(handler: UmbrellaNavigationHandler) {\n    const id = idCounter++;\n    handlerIdList.push({ id, handler });\n\n    if (handlerIdList.length === 1) {\n      startListening();\n    }\n\n    return remove;\n\n    function remove() {\n      const index = handlerIdList.map(({ id }) => id).indexOf(id);\n      if (index >= 0) {\n        handlerIdList.splice(index, 1);\n        if (handlerIdList.length === 0) {\n          stopListening();\n        }\n      }\n    }\n  }\n}\n","import { UmbrellaRoute } from \"./types\";\n\nexport function attemptScrollToTop(\n  route: UmbrellaRoute,\n  scrollToTop: boolean | undefined\n) {\n  if (\n    route.action === \"push\" &&\n    typeof window === \"object\" &&\n    window !== null &&\n    typeof window.scroll === \"function\" &&\n    scrollToTop !== false &&\n    typeof navigator === \"object\" &&\n    navigator !== null &&\n    typeof navigator.userAgent === \"string\" &&\n    !(\n      navigator.userAgent.indexOf(\"Node.js\") > 0 ||\n      navigator.userAgent.indexOf(\"jsdom\") > 0\n    )\n  ) {\n    try {\n      window.scroll(0, 0);\n    } catch {}\n  }\n}\n","import { UmbrellaRoute, UmbrellaRouteDefCollection } from \"./types\";\n\nexport function serializeStateParams(\n  route: UmbrellaRoute,\n  routeDefs: UmbrellaRouteDefCollection\n) {\n  const state: Record<string, string> = {};\n\n  if (route.name) {\n    const sortedParams = Object.keys(route.params).sort();\n    for (const paramName of sortedParams) {\n      const paramDef =\n        routeDefs[route.name][\"~internal\"].params[paramName][\"~internal\"];\n\n      if (paramDef.kind === \"state\") {\n        const value = route.params[paramName];\n        state[paramName] = paramDef.valueSerializer.stringify(value);\n      }\n    }\n  }\n\n  return state;\n}\n","import {\n  CoreRouter,\n  Action,\n  SessionOpts,\n  UmbrellaRouteBuilder,\n  UmbrellaCoreRouter,\n  UmbrellaRoute,\n  UmbrellaRouteDefCollection,\n  RouterContext,\n  UmbrellaBlocker,\n  RouterOpts,\n  NavigateOptions,\n} from \"./types\";\nimport { createRouteBuilder } from \"./createRouteBuilder\";\nimport {\n  createBrowserHistory,\n  History,\n  createMemoryHistory,\n  createHashHistory,\n} from \"history\";\nimport { createQueryStringSerializer } from \"./createQueryStringSerializer\";\nimport { assert } from \"./assert\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { getMatchingRoute } from \"./getMatchingRoute\";\nimport { convertToRouterLocationFromHistoryLocation } from \"./convertToRouterLocationFromHistoryLocation\";\nimport { getRouteByHref } from \"./getRouteByHref\";\nimport { createNavigationHandlerManager } from \"./createNavigationHandlerManager\";\nimport { stringUtils } from \"./stringUtils\";\nimport { attemptScrollToTop } from \"./attemptScrollToTop\";\nimport { serializeStateParams } from \"./serializeStateParams\";\n\nconst { startsWith, splitFirst } = stringUtils;\n\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(routeDefs: TRouteDefCollection): CoreRouter<TRouteDefCollection>;\nexport function createRouter<\n  TRouteDefCollection extends { [routeName: string]: any }\n>(\n  opts: RouterOpts,\n  routeDefs: TRouteDefCollection\n): CoreRouter<TRouteDefCollection>;\nexport function createRouter(...args: any[]): UmbrellaCoreRouter {\n  const { routeDefs, opts } = parseArgs(args);\n\n  const navigationHandlerManager = createNavigationHandlerManager({\n    startListening: () => {\n      unlisten = history.listen((update) => {\n        if (skipNextEnvironmentTriggeredNavigation) {\n          skipNextEnvironmentTriggeredNavigation = false;\n          return;\n        }\n\n        const location = convertToRouterLocationFromHistoryLocation(\n          update.location,\n          baseUrl\n        );\n        const action = update.action.toLowerCase() as Action;\n        const { route, primaryPath } = getMatchingRoute(\n          location,\n          getRouterContext()\n        );\n\n        handleNavigation({ ...route, action }, primaryPath);\n      });\n    },\n    stopListening: () => unlisten?.(),\n  });\n\n  const baseUrl = opts.baseUrl ?? \"/\";\n  const arraySeparator = opts.arrayFormat?.separator ?? \",\";\n  const queryStringSerializer =\n    opts.queryStringSerializer ??\n    createQueryStringSerializer({\n      queryStringArrayFormat: opts.arrayFormat?.queryString,\n      arraySeparator,\n    });\n\n  let history: History;\n  let unlisten: (() => void) | undefined;\n  let skipNextEnvironmentTriggeredNavigation = false;\n  let skipHandlingNextApplicationTriggeredNavigation = false;\n  let initialRoute: UmbrellaRoute | null = null;\n  let previousRoute: UmbrellaRoute | null = null;\n  let blockerCollection: UmbrellaBlocker[] = [];\n\n  applySessionOpts(opts.session);\n\n  const routes = createRouteBuilderCollection(getRouterContext);\n\n  const router: UmbrellaCoreRouter = {\n    routes,\n    session: {\n      push(href, state, options: NavigateOptions) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].push\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"push\" }, primaryPath, options);\n      },\n      replace(href, state, options: NavigateOptions) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].replace\", [\n            assert.numArgs([].slice.call(arguments), 1, 2),\n            assert.type(\"string\", \"href\", href),\n            assert.type([\"object\", \"undefined\"], \"state\", state),\n          ]);\n        }\n\n        const { route, primaryPath } = getRouteByHref(\n          href,\n          state,\n          getRouterContext()\n        );\n\n        return navigate({ ...route, action: \"replace\" }, primaryPath, options);\n      },\n      back(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].back\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(-amount);\n      },\n      forward(amount = 1) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].forward\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"number\", \"amount\", amount),\n          ]);\n        }\n\n        history.go(amount);\n      },\n      getInitialRoute() {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].getInitialRoute\", [\n            assert.numArgs([].slice.call(arguments), 0),\n          ]);\n        }\n\n        if (!initialRoute) {\n          let result = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              history.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          if (!result.primaryPath) {\n            skipHandlingNextApplicationTriggeredNavigation = true;\n            result.route.replace();\n            result = getMatchingRoute(\n              convertToRouterLocationFromHistoryLocation(\n                history.location,\n                baseUrl\n              ),\n              getRouterContext()\n            );\n          }\n          initialRoute = result.route;\n        }\n\n        return initialRoute;\n      },\n      reset(session) {\n        if (__DEV__) {\n          assert(\"[RouterSessionHistory].reset\", [\n            assert.numArgs([].slice.call(arguments), 1),\n            assert.type(\"object\", \"session\", session),\n          ]);\n        }\n\n        return applySessionOpts(session);\n      },\n      block(blocker) {\n        blockerCollection.push(blocker);\n\n        const unblock = history.block((update) => {\n          const { route } = getMatchingRoute(\n            convertToRouterLocationFromHistoryLocation(\n              update.location,\n              baseUrl\n            ),\n            getRouterContext()\n          );\n\n          const action = update.action.toLowerCase() as Action;\n\n          blocker({ route: { ...route, action }, retry: update.retry });\n        });\n\n        return () => {\n          blockerCollection.splice(\n            blockerCollection.findIndex((item) => item === blocker),\n            1\n          );\n\n          unblock();\n        };\n      },\n      listen: (handler) => navigationHandlerManager.add(handler),\n    },\n  };\n\n  return router;\n\n  function applySessionOpts(\n    sessionOpts: SessionOpts = {\n      type:\n        typeof window !== \"undefined\" && typeof window.document !== \"undefined\"\n          ? \"browser\"\n          : \"memory\",\n    }\n  ) {\n    initialRoute = null;\n    if (sessionOpts.type === \"memory\") {\n      history = createMemoryHistory({\n        initialEntries: sessionOpts.initialEntries,\n        initialIndex: sessionOpts.initialIndex,\n      });\n    } else if (sessionOpts.type === \"hash\") {\n      history = createHashHistory({\n        window: sessionOpts.window,\n      });\n    } else {\n      history = createBrowserHistory({\n        window: sessionOpts.window,\n      });\n    }\n  }\n\n  function navigate(\n    route: UmbrellaRoute,\n    primaryPath: boolean,\n    options?: NavigateOptions\n  ) {\n    debugger;\n    if (blockerCollection.length > 0) {\n      blockerCollection.forEach((blocker) => {\n        blocker({\n          route,\n          retry: () => {\n            route[route.action === \"push\" ? \"push\" : \"replace\"](options);\n          },\n        });\n      });\n\n      return;\n    }\n\n    const state = serializeStateParams(route, routeDefs);\n\n    if (\n      previousRoute?.href === route.href &&\n      JSON.stringify(serializeStateParams(previousRoute, routeDefs)) ===\n        JSON.stringify(state)\n    ) {\n      return;\n    }\n\n    if (skipHandlingNextApplicationTriggeredNavigation) {\n      skipHandlingNextApplicationTriggeredNavigation = false;\n    } else if (options?.skipRender) {\n      // do nothing\n    } else {\n      handleNavigation(route, primaryPath);\n    }\n\n    skipNextEnvironmentTriggeredNavigation = true;\n\n    const [pathname, search] = splitFirst(route.href, \"?\");\n\n    history[route.action === \"replace\" ? \"replace\" : \"push\"](\n      {\n        pathname,\n        search: search ? `?${search}` : \"\",\n        hash: \"\",\n      },\n      state ? { state } : undefined\n    );\n  }\n\n  function handleNavigation(route: UmbrellaRoute, primaryPath: boolean) {\n    if (!primaryPath) {\n      route.replace();\n      return;\n    }\n\n    for (const handler of navigationHandlerManager.getHandlers()) {\n      handler(route);\n    }\n\n    attemptScrollToTop(route, opts.scrollToTop);\n\n    previousRoute = route;\n  }\n\n  function getRouterContext(): RouterContext {\n    return {\n      queryStringSerializer,\n      arraySeparator,\n      navigate,\n      history,\n      routeDefs,\n      getRoutes: () => routes,\n      baseUrl,\n    };\n  }\n}\n\nexport function parseArgs(args: any[]) {\n  const routeDefs: UmbrellaRouteDefCollection =\n    args.length === 1 ? args[0] : args[1];\n  const opts: RouterOpts = args.length === 1 ? {} : args[0];\n\n  if (__DEV__) {\n    assert(\"createRouter\", [\n      assert.numArgs(args, 1, 2),\n      assert.collectionOfType(\"RouteDef\", \"routeDefs\", routeDefs),\n      assert.type(\"object\", \"opts\", opts),\n    ]);\n\n    if (opts.arrayFormat?.queryString && opts.queryStringSerializer) {\n      throw TypeRouteError.Query_string_array_format_and_custom_query_string_serializer_may_not_both_be_provided.create();\n    }\n\n    if (typeof opts.baseUrl === \"string\") {\n      if (!startsWith(opts.baseUrl, \"/\")) {\n        throw TypeRouteError.Base_url_must_start_with_a_forward_slash.create(\n          opts.baseUrl\n        );\n      }\n\n      if (\n        opts.baseUrl\n          .split(\"/\")\n          .some((part) => encodeURIComponent(part) !== part)\n      ) {\n        throw TypeRouteError.Base_url_must_not_contain_any_characters_that_must_be_url_encoded.create(\n          opts.baseUrl\n        );\n      }\n    }\n  }\n\n  return { routeDefs, opts };\n}\n\nfunction createRouteBuilderCollection(getRouterContext: () => RouterContext) {\n  const routes: Record<string, UmbrellaRouteBuilder> = {};\n  const { routeDefs } = getRouterContext();\n\n  for (const routeName in routeDefs) {\n    const routeDef = routeDefs[routeName];\n    routes[routeName] = createRouteBuilder(\n      routeName,\n      routeDef,\n      getRouterContext\n    );\n  }\n\n  return routes;\n}\n","import {\n  PathFn,\n  UmbrellaParamDefCollection,\n  RouteDef,\n  UmbrellaRouteDef,\n} from \"./types\";\nimport { TypeRouteError } from \"./TypeRouteError\";\nimport { assert } from \"./assert\";\nimport { asArray } from \"./asArray\";\n\nexport function defineRoute<TParamDefCollection>(\n  params: TParamDefCollection,\n  path: PathFn<TParamDefCollection>\n): RouteDef<TParamDefCollection>;\nexport function defineRoute(path: string | string[]): RouteDef<{}>;\nexport function defineRoute(...args: any[]): UmbrellaRouteDef {\n  assertDefineRouteOrExtendArgs(\"defineRoute\", args);\n\n  const parent = parseArgs(args);\n\n  const routeDef: UmbrellaRouteDef = {\n    \"~internal\": {\n      type: \"RouteDef\",\n      params: parent.params,\n      path: parent.path,\n    },\n    extend(...args: any[]) {\n      assertDefineRouteOrExtendArgs(\"extend\", args);\n\n      const { params, path } = parseArgs(args);\n\n      const parentParamNames = Object.keys(parent.params);\n      const extensionParamNames = Object.keys(params);\n\n      const duplicateParamNames = parentParamNames.filter(\n        (name) => extensionParamNames.indexOf(name) >= 0\n      );\n\n      if (__DEV__) {\n        if (duplicateParamNames.length > 0) {\n          throw TypeRouteError.Extension_route_definition_parameter_names_may_not_be_the_same_as_base_route_definition_parameter_names.create(\n            duplicateParamNames\n          );\n        }\n      }\n\n      return defineRoute(\n        {\n          ...params,\n          ...parent.params,\n        },\n        (x) => {\n          const parentPathArray = asArray(\n            parent.path(filter(parentParamNames))\n          );\n          const childPathArray = asArray(path(filter(extensionParamNames)));\n\n          return ([] as string[]).concat(\n            ...parentPathArray.map((parentPath) =>\n              childPathArray.map((childPath) => {\n                if (parentPath === \"/\") {\n                  return childPath;\n                }\n\n                return parentPath + (childPath === \"/\" ? \"\" : childPath);\n              })\n            )\n          );\n\n          function filter(allowedKeys: string[]) {\n            const filteredX: Record<string, string> = {};\n\n            allowedKeys.forEach((key) => {\n              filteredX[key] = (x as Record<string, string>)[key];\n            });\n\n            return filteredX;\n          }\n        }\n      );\n    },\n  };\n\n  return routeDef;\n}\n\nfunction assertDefineRouteOrExtendArgs(functionName: string, args: any[]) {\n  if (__DEV__) {\n    if (args.length === 1) {\n      if (Array.isArray(args[0])) {\n        assert(functionName, [assert.arrayOfType(\"string\", \"path\", args[0])]);\n      } else {\n        assert(functionName, [assert.type(\"string\", \"path\", args[0])]);\n      }\n    } else {\n      assert(functionName, [\n        assert.numArgs(args, 1, 2),\n        assert.collectionOfType(\"ParamDef\", \"params\", args[0]),\n        assert.type(\"function\", \"path\", args[1]),\n      ]);\n    }\n  }\n}\n\nfunction parseArgs(args: any[]): {\n  params: UmbrellaParamDefCollection;\n  path: PathFn<UmbrellaParamDefCollection>;\n} {\n  return args.length === 1\n    ? {\n        params: {},\n        path: () => args[0],\n      }\n    : {\n        params: args[0],\n        path: args[1],\n      };\n}\n","import { noMatch } from \"./noMatch\";\nimport { ValueSerializer, ParamDefKind, ParamDef, ParamValue } from \"./types\";\nimport { assert } from \"./assert\";\n\nconst boolean: ValueSerializer<boolean> = {\n  id: \"boolean\",\n  parse: (raw) => (raw === \"true\" ? true : raw === \"false\" ? false : noMatch),\n  stringify: (value) => (value ? \"true\" : \"false\"),\n};\n\nconst number: ValueSerializer<number> = {\n  id: \"number\",\n  parse: (raw) => {\n    if (!isNumeric(raw)) {\n      return noMatch;\n    }\n\n    return parseFloat(raw);\n  },\n  stringify: (value) => value.toString(),\n};\n\nfunction isNumeric(value: string) {\n  return !isNaN(parseFloat(value)) && /^-?\\d*\\.?\\d*$/.test(value);\n}\n\nconst string: ValueSerializer<string> = {\n  id: \"string\",\n  parse: (raw) => raw,\n  stringify: (value) => value,\n};\n\nconst json = <TValue = unknown>() => {\n  const valueSerializer: ValueSerializer<TValue> = {\n    id: \"json\",\n    parse: (raw) => {\n      let value: TValue;\n\n      try {\n        value = JSON.parse(raw);\n      } catch {\n        return noMatch;\n      }\n\n      return value;\n    },\n    stringify: (value) => JSON.stringify(value),\n  };\n\n  return valueSerializer;\n};\n\nexport const param = {\n  path: {\n    ...getParamDefKindSection(\"path\", false),\n    trailing: getParamDefKindSection(\"path\", true),\n  },\n  query: getParamDefKindSection(\"query\", false),\n  state: getParamDefKindSection(\"state\", false),\n};\n\nfunction getParamDefKindSection<\n  TKind extends ParamDefKind,\n  TTrailing extends boolean\n>(kind: TKind, trailing: TTrailing) {\n  return {\n    ...getParamDefOptionalitySection(false, false),\n    array: getParamDefOptionalitySection(false, true),\n    optional: {\n      ...getParamDefOptionalitySection(true, false),\n      array: getParamDefOptionalitySection(true, true),\n    },\n  };\n\n  function getParamDefOptionalitySection<\n    TOptional extends boolean,\n    TArray extends boolean\n  >(optional: TOptional, array: TArray) {\n    return {\n      string: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: string,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      number: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: number,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      boolean: getParamDef({\n        \"~internal\": {\n          type: \"ParamDef\",\n          array,\n          kind,\n          optional,\n          valueSerializer: boolean,\n          trailing,\n          default: undefined as never,\n        },\n      }),\n\n      ofType<TValue = unknown>(\n        valueSerializer: ValueSerializer<TValue> = json<TValue>()\n      ) {\n        if (__DEV__) {\n          assert(\"[ParamDef].ofType\", [\n            assert.numArgs([].slice.call(arguments), 0, 1),\n            assert.type(\"object\", \"valueSerializer\", valueSerializer),\n          ]);\n        }\n\n        return getParamDef({\n          \"~internal\": {\n            type: \"ParamDef\",\n            array,\n            kind,\n            optional,\n            valueSerializer,\n            trailing,\n            default: undefined as never,\n          },\n        });\n      },\n    };\n  }\n\n  type GetParamDefResult<T extends ParamDef<TKind>> =\n    T[\"~internal\"][\"optional\"] extends true\n      ? {\n          [\"~internal\"]: T[\"~internal\"];\n          default(value: ParamValue<T>): {\n            [\"~internal\"]: {\n              type: \"ParamDef\";\n              kind: T[\"~internal\"][\"kind\"];\n              array: T[\"~internal\"][\"array\"];\n              valueSerializer: T[\"~internal\"][\"valueSerializer\"];\n              optional: T[\"~internal\"][\"optional\"];\n              default: ParamValue<T>;\n              trailing: T[\"~internal\"][\"trailing\"];\n            };\n          };\n        }\n      : T;\n\n  function getParamDef<T extends ParamDef<TKind>>({\n    \"~internal\": internal,\n  }: T): GetParamDefResult<T> {\n    if (!internal.optional) {\n      return { \"~internal\": internal } as any;\n    }\n\n    return {\n      \"~internal\": internal,\n      default(value: any) {\n        if (__DEV__) {\n          assert(\"[ParamDef].default\", [\n            assert.numArgs([].slice.call(arguments), 1),\n          ]);\n        }\n\n        return {\n          \"~internal\": { ...internal, default: value },\n        };\n      },\n    } as any;\n  }\n}\n","import { RouteGroup, UmbrellaRoute, UmbrellaRouteBuilder } from \"./types\";\nimport { assert } from \"./assert\";\n\nexport function createGroup<T extends any[]>(groupItems: T): RouteGroup<T> {\n  if (__DEV__) {\n    assert(\"createGroup\", [\n      assert.numArgs([].slice.call(arguments), 1),\n      assert.arrayOfType(\n        [\"RouteGroup\", \"RouteBuilder\"],\n        \"groupItems\",\n        groupItems\n      ),\n    ]);\n  }\n\n  const routeNames: Record<string, true> = {};\n\n  groupItems.forEach((item) => {\n    if (isRouteGroup(item)) {\n      item.routeNames.forEach((name) => {\n        routeNames[name] = true;\n      });\n    } else {\n      routeNames[item.name] = true;\n    }\n  });\n\n  return {\n    \"~internal\": {\n      type: \"RouteGroup\",\n      Route: null as any,\n    },\n    routeNames: Object.keys(routeNames),\n    has(route: UmbrellaRoute): route is UmbrellaRoute {\n      if (__DEV__) {\n        assert(\"[RouteGroup].has\", [\n          assert.numArgs([].slice.call(arguments), 1),\n          assert.type(\"object\", \"route\", route),\n        ]);\n      }\n\n      if (route.name === false) {\n        return false;\n      }\n\n      return !!routeNames[route.name];\n    },\n  };\n}\n\nfunction isRouteGroup(\n  value: RouteGroup | UmbrellaRouteBuilder\n): value is RouteGroup {\n  return !!(value as RouteGroup).routeNames;\n}\n"],"names":["asArray","value","Array","isArray","getParamId","parameterName","getParamDefsOfType","type","paramDefCollection","filteredParamDefCollection","Object","keys","forEach","name","paramDef","kind","stringify","urlEncode","result","valueSerializer","encodeURIComponent","noMatch","__noMatch","stringUtils","start","i","length","end","split","_value$split","slice","join","endsWith","startsWith","getObjectMatch","_ref","_step","object","paramDefs","urlEncodeDefault","arraySeparator","params","namedParamDefs","map","_extends","extraneousParams","_loop","raw","undefined","optional","v","array","part","parse","_paramDef$Internal$v","decodeURIComponent","some","_paramDef$Internal$v2","_iterator","_createForOfIteratorHelperLoose","done","_ret","numExtraneousParams","createMatcher","pathDefs","queryParamDefCollection","stateParamDefCollection","defaultParams","paramName","param","_ref2","routerLocation","queryStringSerializer","path","pathMatch","index","match","primaryPath","pathDef","pathHasTrailingSlash","pathSegmentList","segmentIndex","_pathSegmentDef$named2","_pathSegmentDef$named3","_pathSegmentDef$named","pathSegmentDef","pathSegment","namedParamDef","trailing","leading","pathSegmentMinusLeading","pathSegmentMinusLeadingAndTrailing","_pathSegmentDef$named4","Math","max","getPathMatch","queryMatch","query","getQueryMatch","stateMatch","state","getStateMatch","preventDefaultLinkClickBehavior","event","target","defaultPrevented","button","metaKey","altKey","ctrlKey","shiftKey","preventDefault","buildRoute","routeName","location","routerContext","navigate","href","history","createHref","pathname","fullPath","search","baseUrl","route","link","onClick","push","action","options","replace","createRouteBuilder","routeDef","getRouterContext","pathParamDefCollection","getRawPath","namedPathParamDefs","paramIdCollection","rawPath","rawPathSegments","usedPathParams","_step2","rawSegment","includedParamDef","_iterator2","indexOf","_rawSegment$split","filter","build","paramsWithDefault","paramCollection","paramValue","getValue","valueSerializerId","id","_ref3","reduce","key","_extends2","createLocation","defineProperty","Route","createQueryStringSerializer","args","queryStringArrayFormat","_args$queryStringArra","_args$arraySeparator","multiKey","arrayKeySuffix","queryParams","_part$split","rawParamName","rawParamValue","rest","encodedName","getMatchingRoute","routes","getRoutes","nonExactMatch","convertToRouterLocationFromHistoryLocation","rawLocation","splitFirst","getRouteByHref","_splitFirst","createNavigationHandlerManager","startListening","stopListening","handlerIdList","idCounter","add","handler","splice","getHandlers","attemptScrollToTop","scrollToTop","window","scroll","navigator","userAgent","_unused","serializeStateParams","routeDefs","sort","parseArgs","opts","createRouteBuilderCollection","boolean","number","isNaN","parseFloat","test","toString","string","getParamDefKindSection","getParamDefOptionalitySection","getParamDef","~internal","default","ofType","JSON","internal","groupItems","routeNames","item","has","_len","_key","arguments","unlisten","_parseArgs","navigationHandlerManager","listen","update","skipNextEnvironmentTriggeredNavigation","toLowerCase","_getMatchingRoute","handleNavigation","_opts$baseUrl","_opts$arrayFormat$sep","_opts$arrayFormat","arrayFormat","separator","_opts$queryStringSeri","_opts$arrayFormat2","queryString","skipHandlingNextApplicationTriggeredNavigation","initialRoute","previousRoute","blockerCollection","applySessionOpts","session","router","_getRouteByHref","_getRouteByHref2","back","amount","go","forward","getInitialRoute","reset","block","blocker","unblock","retry","findIndex","sessionOpts","document","createMemoryHistory","initialEntries","initialIndex","createHashHistory","createBrowserHistory","_previousRoute","skipRender","hash","defineRoute","parent","extend","_len2","_key2","parentParamNames","extensionParamNames","x","parentPathArray","childPathArray","concat","apply","parentPath","childPath","allowedKeys","filteredX"],"mappings":"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"}